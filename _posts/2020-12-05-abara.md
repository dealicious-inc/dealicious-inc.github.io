---
layout: page
title:  "레거시 코드 및 시스템 리팩토링 - ABARA"
writer: 지준호
thumbnail: 'thumbnail/default.png'
---

## “음…. 어디서부터 이야기를 해야 할까요?”
CTO 님으로부터 레거시 시스템 변환에 대한 기술 블로그 작성을 의뢰 받았다.  
그 순간  1년이 10년 같았던 고난과 좌절 그리고 환희의 순간들이 주마등처럼 머리를 스쳐 지나갔다. 이제 하나씩 이야기 보따리를 풀어 나가 보도록 하겠다. 

# 1. 레거시 시스템 현황
 필자가 입사한 시점은 2019년 6월4일 화요일.  
 내 딸의 생일 다음 날이었다.  
 동대문을 시스템화 한다는 거대한 꿈을 가지고 있는 회사에 부푼 마음을 가지고 힘차게 출근했다. 

>“저 무슨 일부터 해야할까요?”
>
>“일단 소스 보시면서 구조부터 파악하시면 될 것 같습니다.”
>
>“네! 알겠습니다. 여러 모듈이 있던데 git 주소 좀 알려주세요~”
>
>“네. XX와 XX의 git 주소는 OO이고요, XX와 XX의 ftp 주소는 OO입니다. “
>
>“!!!!”

ftp.. 마지막으로 이 단어를 들었던 순간이 언제였을까 한참 생각해보았다. 조금 과장을 하자면 아마도 구한말 순종 8년 때 마지막으로 듣고 못 들어본 단어 같았다. 형상 관리부터 심상치 않음을 느낀 필자는 떨리는 마음으로 한가지 질문을 추가했다. 


>“그.. 그럼 앱이랑 웹에서 사용하는 api 소스는 그 중에 어느 것 일까요?”
>
>“Mobile api 주소는 XX, web api 주소는 OO, 관리자 api 주소는 KK 등등…. 블라 블라 입니다.”
>
>“!!!!”


‘뭐.. 뭐지. 왜 API 주소가 모조리 나눠져 있는거지…. 형상 관리는 좀 구식이지만 MSA(Micro Service Architecture)로 구현된건가’

이런 의문과 두려움을 안고 소스를 하나씩 분석해 나가기 시작했다. 결과는….. 절망 이었다.  
한가지 예를 들어 설명하겠다. 

어떤 상품의 상세 정보를 리턴 하는 API가 있다고 가정한다면, 일반적으로 그 API 하나를 작성하고 나면 그것을 사용하는 매체는 APP 혹은 WEB 이던지 상관없이 쓰고 인증만 다른 구조일 것이다. 그러나 레거시 시스템에서는 모든 매체에 따라 api 서버, 소스가 모두 나눠져 있는 상황이었다. DB 의 어떤 테이블에 컬럼이 하나 추가되었다고 가정하면 관련된 API 만 수정하면 되는게 일반적인데, 레거시 시스템에서는 모든 시스템에서 동일한 부분을 수정해야하는 안타까움이 존재하고 있던 것이었다. 

![](/assets/image/posts/2020-12-05-abara-01.png)
실제로 2019년 7월 경에 약간 복잡도가 있는 모듈을 개발한 경험이 있었는데, 그때 자칫 잘못하면 소스 수정하다가 공황 장애가 올뻔한 적이 있다. 비슷하면서도 살짝 씩 다른 소스를 계속 수정하다보니 데쟈뷰 같기고 하고, 8중 if 문을 따라 들어가다가 길을 잃고 림보 상태에 빠졌다가 겨우 현실 세계로 돌아온 경험이 있었다. 이런 상황에 대해서 위대한 수학자이자 철학자 ‘파타고라스’는 이런 말을 남기기도 하였다. 

 

>“내가 보기엔 이건 답이 없다.” - 피타고라스 -
 

 빛이 보이지 않는 상황이었다. 설상가상으로 서버는 AWS 가 아닌 다른 서비스를 사용하고 있어서 오토 스케일링 같은 유연함도 없는 상황이었고, 어떤 서비스들은 상용 서비스임에도 불구하고 서버 1대로 운영하는 깡(?)을 보여주기도 하였다. 

 왜 시스템이 이런 상황이 되었을까… 회사의 역사를 돌아보게 되었는데, 기존에 너무 적은 인원으로 개발팀을 운영하다보니 운영과 신규 개발 외에는 아예 시간을 할애할 수 없는 상황이었고, 그것을 개선해보고자 개발자들을 새롭게 많이 채용하고 있던 상황이었다. 

 하지만 이런 문제점들을 해결하고자 신규로 개발자들이 입사한만큼 시스템의 안정성과 생산성을 위해서 이대로 두고 볼수는 없었다. 이제부터 여러 개발자들이 모여서 거대한 실타래를 풀어 나간 대장정을 소개하도록 하겠다. 

# 2. 레거시 시스템 분석 및 프레임워크 선택
기존 레거시 시스템을 분석해보니 많은 문제가 발견되었는데 그중에 대표적인 부분을 꼽아보자면 아래와 같다. 

- 코드가 복잡하고 정리되어 있지 않음 (인덴트 포함)
- API 가 파일 별로 나누어져 있고, 그것의 클론이 서버 별로 존재 
- N + 1 쿼리의 페스티벌. DB 성능의 심각한 저하를 일으킴
- 코드의 잠재적 오류와 warning 포인트가 산재함. 깨진 유리창의 법칙
- 테스트 코드 부재

 분석이후 느낀 점은 총체적 난국 이라는 것이었다. 프레임워크도 없는 쌩 PHP 였고, 소스의 가독성도 떨어지고, 모델링도 확장성이 고려되지 않은 부분이 너무 많아서 비슷하면서 다른 역할을 하는 테이블들이 산적해 있었다. 개선해야 할 포인트가 너무 많아서 어디서 부터 손을 대야 할지도 애매한 상황이었다.

**여러번의 회의를 거친 끝에 일단 DB 모델링은 유지한채 개발 언어와 프레임워크를 바꾸기로 하였다.** 

그리고 또 여러번의 회의를 하면서 어떤 언어와 프레임워크 선택 할지 고민에 고민을 거듭했고 아래와 같은 3가지 후보군으로 추려냈다. 

1. 기존 php 소스 개선 및 custom 하게 제작한 프레임워크
2. Laravel
3. Ruby on Rails 

 처음에는 1번안으로 가는게 좋겠다고 생각을 했었다. 그렇게 어느 정도 정리를 하고 나서 시스템 안정화가 된 이후 새로운 프레임워크를 적용하는게 괜찮다고 여겨졌기 때문이다. 

 하지만 첫번째 안은 신규 입사자들이 기존 레거시 시스템에서 몇번의 새로운 모듈을 개발해 본 후  바로 폐기 처분 되었다. 효율성이 극도로 떨어져서 이대로는 어떤 생산성 향상도 기대할 수 없었기 때문이다. 기존 경험에 의해 산정한 공수가 전혀 의미가 없는 상황이었다. 기본적으로 예상한 공수보다 3~5배 정도 오버 되는건 기본이었다. 

그래서 이제 2개의 후보로 압축이 되었다. 

**Laravel 그리고 Ruby on Rails**

 Laravel 이 후보군으로 올라온 이유는 매우 단순한 이유였다. 기존 언어가 php 라는것! 그런데 여기에도 큰 문제가 있었는데, 아무도 Laravel 로 개발한 경험이 없는 상황이었다. 기존 시스템에 대한 유지보수, 신규 개발, 그리고 변환 작업이 동시에 이루어져야 하는 상황에서 Laravel 을 스터디 하면서 상용화 시스템에 적용하기엔 무리가 있었다. 그래서 Laravel 도 최종적으로 드랍이 되었고, Ruby on Rails 가 선택되었다. 

![](/assets/image/posts/2020-12-05-abara-02.png)

 이 회사에 들어와서 느낀 가장 안타까운 부분이 바로 생산성이었다. 복잡한 레거시 시스템과 협업 프로세스의 부재, 규모있는 프로젝트의 경험 부재 등등 여러가지 문제로 인해 신규 기능 오픈이 너무나도 더디게 진행되고 있었고 기획팀과 프론트 파트의 불만이 백엔드 파트로 몰려 있는 상황이었다. 조금 더 신랄하게 비판하자면 백엔드 파트로 인해 여러 가지 업무들이 진행이 안 되고 있는 상황이었다!

 Ruby on Rails를 선택한 가장 큰 이유가 위에서 말한 부분과 일맥상통한다. 바로 생산성이 높은 언어라는 것이다. 다행히 개발자들 중 몇몇이 Ruby on Rails로 프로젝트를 진행한 경험이 있었고 그들도 한목소리로 생산성에 대해서 칭찬을 아끼지 않았다. 최근 스타트업 회사들이 높은 생산성을 이유로 Ruby on Rails를 선택하는 곳이 많은데 더 자세한 내용은 아래 블로그를 참조하기 바란다. 

[참고 블로그 글](https://brunch.co.kr/@jamess/44)

 
# 3. 레거시 변환 작업
 가장 먼저 해야할 일은 Ruby on Rails 스터디, 코딩이 아닌 작업 방식의 결정이었다. 기존에 일했던 방식을 예를 들어 설명하면 기획자가 ‘A에서 B라는 기능을 개선’ 이라는 일을 가져왔다고 치자. 그럼 개발자가 지정되고 개발 이후 기획자가 확인하면 오케이 사인이 떨어지고 상용서비스에 적용 하는 간단한 프로세스 였다. 그런데 정말 충격적인 것이 있었는데 거의 모든 일정에 deadline 이 없었다! 그러다보니 2주 정도에 끝내려고 했던 일을 3주~4주에 걸려서 끝나더라도 아무도 뭐라 하지 않는 엄청난 일들이 비일비재하게 일어나고 있었던 것이었다.   
 위에 예시로 든 일은 소규모 프로젝트를 진행할때는 그래도 할만 하다. 하지만 이번 변환 작업은 백엔드 개발자가 모두 붙어야 하고, 프론트 파트와도 면밀하게 진행되어야 했었는데 기존 방식으로는 무리가 있었다. 코드의 신뢰성 문제는 또 다른 별개의 문제였다. 그래서 아래와 같은 것들을 도입하기 시작했다. 

![](/assets/image/posts/2020-12-05-abara-03.png)

1. 프로젝트 명 정하기 (ABARA)
2. 협업 도구 제대로 활용 하기 : slack, jira, github
3. 코드 리뷰를 통해 코드 신뢰도 높이기
4. swagger를 제공하여 프론트 파트가 쉽게 연동 테스트 할 수 있도록 제공하기
5. json 규격 정하기 

 
## 프로젝트 명 - ABARA

 일반적으로 어느정도 프로세스가 정립이 된 회사라면 당연히 사용하고 있었을 환경을 하나씩 정립해 나가기 시작했다. 프로젝트명은 ABARA 로 정했는데 이유는…. 그냥 필자가 가장 좋아하는 음료 였다…. 프로젝트 진행 중에 아바라를 얼마나 많이 마셨는지, 작년 겨울에 스타벅스 프리퀀시를 2개나 교환하게 된 훈훈한 일도 있었다. 뒤늦게 입사한 분들은 개발자들이 하도 아바라가 어쩌구, 거기 기능이 어쩌구 말을 하다보니 무슨 새로운 프레임워크가 나왔나 하면서 구글에 검색을 했다가 아이스 바닐라 라떼 사진만 엄청 봤다고 하는 이야기를 듣기도 하였다. 


## 변환 작업 진행
![](/assets/image/posts/2020-12-05-abara-04.png)


 위의 그림과 같이 백엔드 개발자들이 컨버팅 해야 할 api 를 각각 할당하고 진행상황을 면밀히 보면서 진행하였다. 일단 앱과 웹에서 사용하는 api 를 컨버팅하기로 하였는데, 갯수는 약 260개 정도 였다. (위의 숫자는 소매 api 의 숫자로 전체 변환 갯수와는 차이가 있다.)   
 먼저 기본 구조를 잡는 일에 어느 정도 시간이 소요되었고, Ruby on Rails 에 익숙하지 않은 개발자들에게 시니어 개발자들이 코드리뷰를 해주면서 진행했는데 **소요된 기간은 총 4개월** 이었다. 길다면 길다고 할 수 있는 기간인데 레거시 코드를 새로운 프레임워크로 변환 하는 작업을 해본 사람들이라면 이 기간이 얼마나 빠르게 진행한 프로젝트인지 알 수 있을 것이다.   

이 4개월 기간 동안 단순 변환 작업만 한 것은 아니다. 도저히 기존 구조를 안고 갈 수 없는 부분들은 리팩토링을 하면서 진행했는데 대표적인 부분이 로그인 프로세스와 푸시 시스템 이었다. 

 기존 레거시 api 에서 앱과의 통신을 위해 token 방식의 인증을 사용하고 있었는데, 이때 사용한 token 이 큰 문제가 있었다. User 의 여러가지 정보(userid, passwd 등등) 을 조합하여 암호화 과정을 거친 token 을 사용하고 있었는데, 가장 큰 문제는 패스워드나 주요 정보가 바뀌기 전까지는 그 token 이 바뀌지 않고 계속 사용된다는 부분 이었다. 그래서 한번 token 이 노출되게 되면 그 토큰으로 거의 모든 정보를 이용할 수 있는 상황이었고 이런 취약점으로 인해 수많은 크롤링 업체들이 신상마켓의 주요 상품 정보들을 아주 쉽게 퍼갈 수 있었다. 그래서 KAMA 라고 불리우는 별도의 서브 프로젝트가 탄생되었다. (KAMA는 다들 알다시피(?) 카라멜 마키아또의 약자다!)

![](/assets/image/posts/2020-12-05-abara-05.png)

 로그인 개선 프로젝트 KAMA로 인해 사라진 DB 테이블 갯수가 무려 **21개** 였다! 오랜만에 속이 뻥 뚫리는 듯한 시원함을 느낄 수 있었고 이런 경험들을 더 많이 하고 싶다는 의욕이 올라오기 시작했다.  
 
 그리고 단순이 테이블이 줄어든 것만이 아닌 보안적인 부분도 강화되어서 기존처럼 유저의 정보 변화가 없다면 token 도 변하지 않는 방식이 아닌 로그인 할 때마다 변화할 수 있게  token, refresh_token 을 활용하게 되었다. 

![](/assets/image/posts/2020-12-05-abara-06.png)

 푸쉬 시스템도 극적인 변화를 맞이하였는데 기존에 여러 인스턴스와 큐를 사용하여 JAVA로 별도로 구축되었던 서비스를 severless 형태로 재구축 하였고 이 부분은 별도로 따로 소개하겠다. 일단 구조도만 보면 아래와 같은 시스템으로 변경되었다. 
 
 ![](/assets/image/posts/2020-12-05-abara-07.png)

## 테스트 코드 도입

 기존 레거시 시스템의 큰 문제점 중 하나는 테스트 코드의 부재 였고, 테스트 코드가 없는 시스템은 생각보다 많은 취약점이 발생한다. 

 쉽게 예를 들어 설명해 보겠다. A라고 하는 공통적으로 많이 사용하는 DB table에 어떤 수정이 이루어졌다고 가정했을 때, 그 시스템이 작은 규모라면 이런 저런 사이드 이펙트를 고려하면서 개발을 하게 될 것이다. 그러다 시스템 규모가 커졌다면 어떻게 될까? 모든 사이드 이펙트를 찾아서 수정한다는건 잡스 형이 와도 쉽지 않은 일이 될 것이다. 그러나 테스트 코드가 있다면 어떻게 될까? table 수정과 관련된 개발을 진행 한 이후 전체적으로 테스트 코드를 돌려본다면 개발자가 예상하지 못한 부분의 사이드 이펙트를 쉽게 검출할 수 있게 된다! 그리고 만약 테스트 코드에서 안 잡힌 오류가 상용서비스에서 발견된다면 테스트 코드를 지속적으로 개선하면서 시스템의 안정성을 높일 수 있게 된다. 

 다행히 Ruby 에는 쉽게 테스트 코드를 작성할 수 있는 rspec 이라는 것이 존재했고, 모든 api 에 대한 테스트 케이스를 같이 개발하였다. 처음에는 테스트 코드 작성에 익숙치 않아서 여러 가지 시행착오를 겪기도 하였는데 대표적인 것이 테스트 DB를 다 날린 일들 이었다. 지금은 노하우가 쌓여서 여러 가지 방법과 장치로 그런 일들은 일어나지 않고 있다!

 아래 그림은 새로운 테이블을 추가했을때 발생한 테스트 케이스 오류 화면이다. 이런 식으로 사이드 이펙트에 대한 부분을  배포 전에 먼저 인지하고 처리할 수 있게 된다. 

 ![](/assets/image/posts/2020-12-05-abara-08.png)
 

## 협업 도구 활용

 기존 레거시 시스템에서는 프론트와 협업을 할때 api 명세서의 부실한 부분과 swaager의 부재로 체계적인 협업이 어려웠었다. 회사 규모가 작고 개발자가 몇명 없었을 때는 이런 부분도 큰 문제가 되지 않는다. 막히면 옆에 가서 물어보면 그만이기 때문이다. 하지만 현재의 상황에서 기존의 방식으로 협업을 하게 되면 아마도 가장 조용해야 할 개발팀 공간이 5일장이 열린 것 마냥 엄청 시끄러운 공간이 될 것이 자명했다. 

 그래서 swagger를 통해 프론트에서 쉽게 api 의 동작을 확인 할 수 있도록 지원하였고, swagger로 부족한 부분은 Jira 티켓을 통해 상세한 내용을 확인 할 수 있도록 하였다. 이런 부분이 쉽게 가능했던 부분은 일반적인 오픈 소스 프로젝트 방식처럼 모든 작업은 상세히 Jira 티켓을 발급하고 진행했기 때문이다.

 (아래 그림에서 swagger 이름이 macaron 인 것은 초기에 프로젝트명이 macaron 이었기 때문이다! )

 ![](/assets/image/posts/2020-12-05-abara-09.png)


## json 규격 정하기

 기존에는 제대로 된 json 규격 문서가 없었다. 그래서 변환 작업을 하면서도 임의로 백엔드 파트에서 json 규격을 정해서 진행하게 되었는데, 이후 프론트와 연동을 진행 할때  규격화 되지 않은 json 으로 인해 프론트 파트가 혼란을 겪기도 하였다. 

 그래서 프론트 파트와 협의하여 json 규격을 정하게 되었고, 현재도 정확한 규격 문서로 인해 신규로 입사한 개발자 분들도 어려움 없이 규격화 된 api 를 개발할 수 있게 되었다. 아래 그림은 json 규격 문서은 한 부분이다. 
 
 ![](/assets/image/posts/2020-12-05-abara-10.png)


## 모니터링 툴 도입

 조금 더 나은 무결성한 시스템을 위해 모니터링 툴 newrelic 과 centry 를 적용하였고, 상시로 모니터링 하면서 오류가 나는 부분들은 꼭 운영팀에서 접수 되지 않더라도 선제 대응을 할 수 있게 되었다. 물론 그렇다고 완벽하게 커버가 가능한 것은 아니지만 선제 대응을 할 수 있는 것과 아닌 것은 천지차이가 있다. 전체적인 모니터링 부분은 newrelic이 담당하고 있고, application 레벨의 오류의 발견은 centry가 담당하고 있다.  슬랙과의 연동을 통해서 오류 발생시 알람을 발생하게 하였고 이로 인해 백엔드 파트원들의 만성피로도가 크게 증가한 부분은 안타깝게 생각 하고 있다….

 

# 4. ABARA 오픈!
 드디어 2019년 11월 말! 4개월간의 변환 작업이 마무리 되었다. 물론 이후 작업도 많이 남았지만 일단 APP과 WEB에서 사용할 모든 API 변환이 완료되었고, 이후 테스트 케이스를 돌렸을때 0개의 오류가 나오게 되었다!  web 과 app 이 순차적으로 새로운 api가 연동된 버전으로 오픈하게 되었고 이 모든 과정은 2020년 상반기에 이루어졌다. 

 기능적으로 개선이 된 것이 아니기에 app 또는 web을 사용하는 고객들은 변화를 느낄 수 없었지만 회사 내부적으로는 큰 변화였다. 이제 더 이상 백엔드 작업으로 인한 프론트 개발 일정 지연이 발생하지 않게 되었고 보안 부분도 많이 개선되었으며, AWS 인프라 구축, 새로운 기능을 위한 오픈 소스 라이브러리 적용 등등 엄청난 이점들을 몸으로 느낄 수 있게 되었다. 

 레거시와 비교했을 때 생산성의 향상은 어느 정도 이루어졌을까? 필자가 느끼는 체감도는 5배~10배이다!! 최근 여러 가지 새로운 모듈을 ABARA 에서 개발하면서 엄청난 생산성을 느낄 수 있었고 모두 정확한 공수 산정을 예측할 수 있게 되었다. 아마도 백엔드 파트 뿐만 아니라 프론트 파트 분들도 이런 부분은 체감할 수 있을 것이라 생각 된다. 

 ![](/assets/image/posts/2020-12-05-abara-11.png)

 위에서 레거시 시스템

 

# 5. 맺음말
 다시 한번 언급하지만 레거시 시스템 변환은 생각보다 까다로운 작업이다. 이미 상용화 된 서비스를 중단 없이 새로운 시스템으로 연동해야하는데 대부분의 회사에서 이런 작업을 진행할 때, 예상보다 몇배의 일정 혹은 비용이 증가한 경험을 했을 것이다. 그리고 그 실패의 책임을 엉뚱한 사람들에게 뒤집어 씌워서 퇴사 시키는 케이스도 종종 주변에서 들을 수 있었다. 딜리셔스에서 이렇게 성공적으로 변환 할 수 있었던 이유는 단순하다. 실제 작업을 한 개발자부터 CTO, 대표에 이르기까지 전폭적인 지원을 아끼지 않았고 한 마음 한 뜻으로 일을 진행했기 때문이다. 그래서 개발자들은 더욱 믿음에 보답하려 노력을 하였고 그 결과과 이렇게 성공적인 변환을 이루어 낸 것이라 생각된다. 

 ![](/assets/image/posts/2020-12-05-abara-12.png)
*역전의 용사들!!*

 

 아직 모든 레거시가 변환 된 것은 아니다. 현재도 관리 시스템의 레거시가 존재하고 열심히 컨버팅을 하고 있다. 이 부분도 부분 오픈이 되어 실제 상용 서비스에 적용되었고, 내년 1분기 안에 모든 작업이 종료되지 않을까 예상된다. 

 레거시 변환이 완료되면 이제 비로소 여러 모듈들의 제대로 된 리팩토링을 진행 할 수 있게 된다. 물론 변환 작업 중에도 필요한 부분들은 리팩토링을 진행하였지만 워낙에 소스들이 여러 서버로 산발적으로 퍼져 있었기 때문에 쉽게 리팩토링을 진행 할 수 없었다. 하다 못해 counter cache 같은 부분도 적용하기 어려운 실정이었다. 이제서야 좋은 생산성이 나올 수 있는 시스템으로 인해 비슷한 출발선에 서게 되었다. 우리가 가려고 하는 시스템의 진화 단계를 그려보자면 이제 도구를 그나마 쓸 수 있는 중간 정도 온 듯한 느낌이다. 

  ![](/assets/image/posts/2020-12-05-abara-13.png)
 
 ABARA 프로젝트를 통해 많은 자신감을 얻게 되었고, 현재 진행되는 혹은 진행 될 프로젝트를 보면 아무도, 그 누구도 “이건 못 하겠는데요” 라는 말을 하지 않는다. 더 많이 발전할 수 있고, 더 좋은 시스템을 만들어 낼 것이다. 그리고 이런 작업들을 통해 우리는 딜리셔스의 모토를 실현하고자 한다. 

 

### 패션 사업을 쉽고 즐겁게!~~
